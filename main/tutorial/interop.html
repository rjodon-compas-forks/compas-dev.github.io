
<!DOCTYPE html>

<html lang="en">
<head>
<title>compas -- additonal packages</title>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
<meta content="Tom Van Mele" name="author"/>
<meta content="compas is a computational framework for research in architecture and structures." name="description"/>
<link href="/_static/images/compas.ico" rel="shortcut icon" type="image/x-icon"/>
<link crossorigin="anonymous" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/css/bootstrap.min.css" integrity="sha384-/Y6pD6FV/Vv2HJnA6t+vslU6fwYXjCFtcEpHbNJ0lyAFsXTsjBbfaDjzALeQsN6M" rel="stylesheet">
<link href="/_static/css/github.css" rel="stylesheet" type="text/css"/>
<link href="/_static/css/compas.css" rel="stylesheet" type="text/css"/>
<link href="/_static/css/compas-reference.css" rel="stylesheet" type="text/css"/>
<link href="tools.html" rel="next" title="Making tools"/>
<link href="cpython.html" rel="prev" title="CPython in Rhino"/>
<script async="" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>
</link></head>
<body data-spy="scroll" data-target="#compas-localnav">
<header class="navbar navbar-expand compas-navbar">
<a class="navbar-brand" href="/">
<img alt="compas" height="36px" src="/_static/images/compas_icon.png" width="36px"/>
</a>
<ul class="navbar-nav">
<li class="nav-item active">
<a class="nav-link active" href="/main/">Main library</a>
</li>
<li class="nav-item ">
<a class="nav-link " href="/packages/">Additional Packages</a>
</li>
<li class="nav-item">
<a class="nav-link" href="http://forum.compas-framework.org">Forum</a>
</li>
</ul>
</header>
<div class="container-fluid compas-container">
<div class="row flex-xl-nowrap">
<main class="col-12 col-md-9 col-xl-8 compas-content" role="main">
<!-- 
    <nav class="breadcrumb">
        <a class="breadcrumb-item" href="https://compas-dev.github.io/">compas</a>
        <a class="breadcrumb-item" href="https://compas-dev.github.io/packages">additional packages</a>
        
            
                <a class="breadcrumb-item" href="../tutorial.html" accesskey="U">tutorial</a>
            
        
    </nav>
 -->
<div class="section">
<h1>Using C/C++ code</h1>
<div class="section">
<h2>Summary</h2>
<p>In this tutorial we will write a smoothing function in C++ and make it available
directly in Python. We will also use a callback to live visualise the iterations
of the algorithm and to dynamically change the boundary conditions. An
implementation of the code in this tutorial is available in the geometry package:</p>
<ul class="simple">
<li><p><code class="xref py py-func docutils literal">compas.geometry.smooth_centroid_cpp()</code></p></li>
</ul>
</div>
<div class="section">
<h2>Requirements</h2>
<ul class="simple">
<li><p>a C++ compiler (for example g++, which is part of the GNU compiler collection)</p></li>
</ul>
</div>
<div class="section">
<h2>Setup</h2>
<p>For this tutorial, we will use the following files and folders:</p>
<div class="highlight"><pre><code class="language-python border rounded"><span></span><span class="o">+</span> <span class="n">smoothing_cpp</span>
    <span class="o">+</span> <span class="n">src</span>
        <span class="o">-</span> <span class="n">main</span><span class="o">.</span><span class="n">cpp</span>
    <span class="o">-</span> <span class="n">smoothing</span><span class="o">.</span><span class="n">so</span>
    <span class="o">-</span> <span class="n">smoothing</span><span class="o">.</span><span class="n">py</span>
</code></pre></div>

</div>
<div class="section">
<h2>The smoothing function</h2>
<p>First, the C++ code. The smoothing function will implement a simple barycentric
smoothing algorithm, in which at every iteration, each vertex is moved to the
barycentre of its neighbours.</p>
<p>By the way, I have no real experience in writing C++ code, so i am sure that this
can be done a lot more elegantly and efficiently.
I would be happy to hear about any and all suggestions (<a class="reference external" href="mailto:vanmelet%40ethz.ch">vanmelet<span>@</span>ethz<span>.</span>ch</a>).</p>
<div class="highlight"><pre><code class="language-python border rounded"><span></span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">extern</span> <span class="s">"C"</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="kt">void</span> <span class="n">callback</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">smooth_centroid</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nbrs</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">fixed</span><span class="p">,</span> <span class="kt">double</span> <span class="o">**</span><span class="n">vertices</span><span class="p">,</span> <span class="kt">int</span> <span class="o">**</span><span class="n">neighbours</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kmax</span><span class="p">,</span> <span class="n">callback</span> <span class="n">func</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">smooth_centroid</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nbrs</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">fixed</span><span class="p">,</span> <span class="kt">double</span> <span class="o">**</span><span class="n">vertices</span><span class="p">,</span> <span class="kt">int</span> <span class="o">**</span><span class="n">neighbours</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kmax</span><span class="p">,</span> <span class="n">callback</span> <span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span><span class="p">;</span>

    <span class="n">vector</span><span class="o">&lt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">xyz</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">));</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">kmax</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// make a copy of the current vertex positions</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
            <span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
            <span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="c1">// move each vertex to the barycentre of its neighbours</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

            <span class="c1">// skip the vertex if it is fixed</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">fixed</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">cx</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
            <span class="n">cy</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
            <span class="n">cz</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>

            <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nbrs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">neighbours</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>

                <span class="n">cx</span> <span class="o">+=</span> <span class="n">xyz</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
                <span class="n">cy</span> <span class="o">+=</span> <span class="n">xyz</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
                <span class="n">cz</span> <span class="o">+=</span> <span class="n">xyz</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
            <span class="p">}</span>

            <span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cx</span> <span class="o">/</span> <span class="n">nbrs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cy</span> <span class="o">/</span> <span class="n">nbrs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cz</span> <span class="o">/</span> <span class="n">nbrs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="c1">// call the callback</span>

        <span class="n">func</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

</div>
<div class="section">
<h2>The <code class="docutils literal">ctypes</code> wrapper</h2>
<p>Looking a the signature of the C++ function, the code is expecting the following
input arguments:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal">int v</code></p></li>
<li><p><code class="docutils literal">int *nbrs</code></p></li>
<li><p><code class="docutils literal">int *fixed</code></p></li>
<li><p><code class="docutils literal">double **vertices</code></p></li>
<li><p><code class="docutils literal">int **neighbours</code></p></li>
<li><p><code class="docutils literal">int kmax</code></p></li>
<li><p><code class="docutils literal">callback func</code></p></li>
</ol>
<p>Or, in other words:</p>
<ol class="arabic simple">
<li><p>the number of vertices, as an integer</p></li>
<li><p>the number of neighbours per vertex, as a an array of integers</p></li>
<li><p>a mask identifying the fixed vertices, as an array of integers (0/1)</p></li>
<li><p>the vertex coordinates, as a two-dimensional array of doubles</p></li>
<li><p>the vertex neighbours, as a two-dimensional array of integers</p></li>
<li><p>the maximum number of iterations, as an integer</p></li>
<li><p>the callback function, as a function of type callback</p></li>
</ol>
<p>Note that the sizes of the arrays are unknown at compile time, since they depend
on the number of vertices in the system. Therefore they are passed as pointers.
My understanding of this is based on whatever google spat out and a few SO posts…</p>
<ul class="simple">
<li><p><a class="reference external" href="https://stackoverflow.com/questions/8767166/passing-a-2d-array-to-a-c-function">https://stackoverflow.com/questions/8767166/passing-a-2d-array-to-a-c-function</a></p></li>
<li><p><a class="reference external" href="https://stackoverflow.com/questions/8767166/passing-a-2d-array-to-a-c-function/17569578#17569578">https://stackoverflow.com/questions/8767166/passing-a-2d-array-to-a-c-function/17569578#17569578</a></p></li>
<li><p><a class="reference external" href="http://www.cplusplus.com/doc/tutorial/arrays/">http://www.cplusplus.com/doc/tutorial/arrays/</a></p></li>
</ul>
<p>We want to be able to call the function from Python, which essentially boils down
to something like this:</p>
<div class="highlight"><pre><code class="language-python border rounded"><span></span><span class="kn">import</span> <span class="nn">ctypes</span>
<span class="kn">import</span> <span class="nn">compas</span>
<span class="kn">from</span> <span class="nn">compas.datastructures</span> <span class="kn">import</span> <span class="n">Mesh</span>
<span class="kn">from</span> <span class="nn">compas.plotters</span> <span class="kn">import</span> <span class="n">MeshPlotter</span>
<span class="kn">from</span> <span class="nn">compas.interop.core.cpp.xdarray</span> <span class="kn">import</span> <span class="n">Array1D</span>
<span class="kn">from</span> <span class="nn">compas.interop.core.cpp.xdarray</span> <span class="kn">import</span> <span class="n">Array2D</span>

<span class="c1"># get the C++ smoothing library</span>

<span class="n">smoothing</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">cdll</span><span class="o">.</span><span class="n">LoadLibrary</span><span class="p">(</span><span class="s1">'smoothing.so'</span><span class="p">)</span>

<span class="c1"># make a mesh</span>

<span class="n">mesh</span> <span class="o">=</span> <span class="n">Mesh</span><span class="o">.</span><span class="n">from_obj</span><span class="p">(</span><span class="n">compas</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'faces.obj'</span><span class="p">))</span>

<span class="c1"># extract the required data for smoothing</span>

<span class="n">vertices</span>   <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">get_vertices_attributes</span><span class="p">(</span><span class="s1">'xyz'</span><span class="p">)</span>
<span class="n">adjacency</span>  <span class="o">=</span> <span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertex_neighbours</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">()]</span>
<span class="n">fixed</span>      <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertex_degree</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">()]</span>
<span class="n">v</span>          <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
<span class="n">nbrs</span>       <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">adjacency</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span>
<span class="n">neighbours</span> <span class="o">=</span> <span class="p">[</span><span class="n">adjacency</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">10</span> <span class="o">-</span> <span class="n">nbrs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span>
<span class="n">kmax</span>       <span class="o">=</span> <span class="mi">50</span>

<span class="c1"># ==============================================================================</span>
<span class="c1"># convert the python data to C-compatible types</span>
<span class="c1"># ==============================================================================</span>

<span class="c1"># ...</span>

<span class="c1"># ==============================================================================</span>

<span class="c1"># make a plotter for visualisation</span>

<span class="n">plotter</span> <span class="o">=</span> <span class="n">MeshPlotter</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>

<span class="c1"># plot the original line geometry as a reference</span>

<span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
        <span class="s1">'start'</span><span class="p">:</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertex_coordinates</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">'xy'</span><span class="p">),</span>
        <span class="s1">'end'</span>  <span class="p">:</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertex_coordinates</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">'xy'</span><span class="p">),</span>
        <span class="s1">'color'</span><span class="p">:</span> <span class="s1">'#cccccc'</span><span class="p">,</span>
        <span class="s1">'width'</span><span class="p">:</span> <span class="mf">0.5</span>
    <span class="p">})</span>

<span class="n">plotter</span><span class="o">.</span><span class="n">draw_lines</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

<span class="c1"># plot the starting point</span>

<span class="n">plotter</span><span class="o">.</span><span class="n">draw_vertices</span><span class="p">()</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">draw_edges</span><span class="p">()</span>

<span class="n">plotter</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">pause</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># ==============================================================================</span>
<span class="c1"># define the callback function</span>
<span class="c1"># ==============================================================================</span>

<span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

    <span class="c1"># update the plot</span>
    <span class="c1"># and change the boundary conditions</span>

    <span class="c1"># ...</span>

<span class="c1"># ==============================================================================</span>

<span class="c1"># ==============================================================================</span>
<span class="c1"># set the argument types for the smoothing function</span>
<span class="c1"># and call it with C-compatible data</span>
<span class="c1"># ==============================================================================</span>

<span class="n">smoothing</span><span class="o">.</span><span class="n">smooth_centroid</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span>

<span class="n">smoothing</span><span class="o">.</span><span class="n">smooth_centroid</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="c1"># ==============================================================================</span>
</code></pre></div>

<div class="section">
<h3>C-compatible types and data</h3>
<p>Some of these conversion are quite trivial. For example, converting an integer is simply:</p>
<div class="highlight"><pre><code class="language-python border rounded"><span></span><span class="n">c_v</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</code></pre></div>

<p>Also the 1D arrays are not too complicated. For example:</p>
<div class="highlight"><pre><code class="language-python border rounded"><span></span><span class="n">c_fixed_type</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span> <span class="o">*</span> <span class="n">v</span>
<span class="n">c_fixed_data</span> <span class="o">=</span> <span class="n">c_fixed_type</span><span class="p">(</span><span class="o">*</span><span class="n">fixed</span><span class="p">)</span>
</code></pre></div>

<p>The 2D arrays are already a bit trickier. For example:</p>
<div class="highlight"><pre><code class="language-python border rounded"><span></span><span class="n">c_vertex_type</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span> <span class="o">*</span> <span class="mi">3</span>
<span class="n">c_vertices_type</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span>
<span class="n">c_vertices_data</span> <span class="o">=</span> <span class="n">c_vertices_type</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">c_vertex_type</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">])</span>
</code></pre></div>

<p>Converting the callback is also quite straightforward:</p>
<div class="highlight"><pre><code class="language-python border rounded"><span></span><span class="n">c_callback_type</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">CFUNCTYPE</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)</span>
<span class="n">c_callback</span> <span class="o">=</span> <span class="n">c_callback_type</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>
</code></pre></div>

<p>To simplify the construction of C-compatible types, and C-compatible data,
there are a few helper classes in <a class="reference internal" href="../reference/compas.interop.html#module-compas.interop" title="compas.interop"><code class="xref py py-mod docutils literal">compas.interop</code></a>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../reference/generated/compas.interop.core.cpp.xdarray.Array1D.html#compas.interop.core.cpp.xdarray.Array1D" title="compas.interop.core.cpp.xdarray.Array1D"><code class="xref py py-class docutils literal">compas.interop.core.cpp.xdarray.Array1D</code></a></p></li>
<li><p><a class="reference internal" href="../reference/generated/compas.interop.core.cpp.xdarray.Array2D.html#compas.interop.core.cpp.xdarray.Array2D" title="compas.interop.core.cpp.xdarray.Array2D"><code class="xref py py-class docutils literal">compas.interop.core.cpp.xdarray.Array2D</code></a></p></li>
<li><p><a class="reference internal" href="../reference/generated/compas.interop.core.cpp.xdarray.Array3D.html#compas.interop.core.cpp.xdarray.Array3D" title="compas.interop.core.cpp.xdarray.Array3D"><code class="xref py py-class docutils literal">compas.interop.core.cpp.xdarray.Array3D</code></a></p></li>
</ul>
<p>With these helpers, the code for the conversion becomes:</p>
<div class="highlight"><pre><code class="language-python border rounded"><span></span><span class="c1"># ==============================================================================</span>
<span class="c1"># convert the python data to C-compatible types</span>
<span class="c1"># ==============================================================================</span>

<span class="n">c_nbrs</span>       <span class="o">=</span> <span class="n">Array1D</span><span class="p">(</span><span class="n">nbrs</span><span class="p">,</span> <span class="s1">'int'</span><span class="p">)</span>
<span class="n">c_fixed</span>      <span class="o">=</span> <span class="n">Array1D</span><span class="p">(</span><span class="n">fixed</span><span class="p">,</span> <span class="s1">'int'</span><span class="p">)</span>
<span class="n">c_vertices</span>   <span class="o">=</span> <span class="n">Array2D</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="s1">'double'</span><span class="p">)</span>
<span class="n">c_neighbours</span> <span class="o">=</span> <span class="n">Array2D</span><span class="p">(</span><span class="n">neighbours</span><span class="p">,</span> <span class="s1">'int'</span><span class="p">)</span>
<span class="n">c_callback</span>   <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">CFUNCTYPE</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">)</span>

<span class="c1"># ==============================================================================</span>
</code></pre></div>

<p>Then we let the smoothing function what it can expect in terms of types by setting
the argument types of the callable:</p>
<div class="highlight"><pre><code class="language-python border rounded"><span></span><span class="c1"># ==============================================================================</span>
<span class="c1"># set the argument types for the smoothing function</span>
<span class="c1"># and call it with C-compatible data</span>
<span class="c1"># ==============================================================================</span>

<span class="n">smoothing</span><span class="o">.</span><span class="n">smooth_centroid</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">c_int</span><span class="p">,</span>
    <span class="n">c_nbrs</span><span class="o">.</span><span class="n">ctype</span><span class="p">,</span>
    <span class="n">c_fixed</span><span class="o">.</span><span class="n">ctype</span><span class="p">,</span>
    <span class="n">c_vertices</span><span class="o">.</span><span class="n">ctype</span><span class="p">,</span>
    <span class="n">c_neighbours</span><span class="o">.</span><span class="n">ctype</span><span class="p">,</span>
    <span class="n">c_int</span><span class="p">,</span>
    <span class="n">c_callback</span>
<span class="p">]</span>

<span class="n">smoothing</span><span class="o">.</span><span class="n">smooth_centroid</span><span class="p">(</span>
    <span class="n">c_int</span><span class="p">(</span><span class="n">v</span><span class="p">),</span>
    <span class="n">c_nbrs</span><span class="o">.</span><span class="n">cdata</span><span class="p">,</span>
    <span class="n">c_fixed</span><span class="o">.</span><span class="n">cdata</span><span class="p">,</span>
    <span class="n">c_vertices</span><span class="o">.</span><span class="n">cdata</span><span class="p">,</span>
    <span class="n">c_neighbours</span><span class="o">.</span><span class="n">cdata</span><span class="p">,</span>
    <span class="n">c_int</span><span class="p">(</span><span class="n">kmax</span><span class="p">),</span>
    <span class="n">c_callback</span><span class="p">(</span><span class="n">wrapper</span><span class="p">)</span>
<span class="p">)</span>

<span class="c1"># ==============================================================================</span>
</code></pre></div>

<p>The last step is to define the functionality of the callback.
The goal is to visualise the changing geometry
and to change the location of the fixed points
during the smoothing process; in C++, but from Python.</p>
<div class="highlight"><pre><code class="language-python border rounded"><span></span><span class="c1"># ==============================================================================</span>
<span class="c1"># define the callback function</span>
<span class="c1"># ==============================================================================</span>

<span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

    <span class="n">xyz</span> <span class="o">=</span> <span class="n">c_vertices</span><span class="o">.</span><span class="n">cdata</span>

    <span class="c1"># change the boundary conditions</span>

    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">kmax</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">xyz</span><span class="p">[</span><span class="mi">18</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># update the plot</span>

    <span class="n">plotter</span><span class="o">.</span><span class="n">update_vertices</span><span class="p">()</span>
    <span class="n">plotter</span><span class="o">.</span><span class="n">update_edges</span><span class="p">()</span>
    <span class="n">plotter</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">pause</span><span class="o">=</span><span class="mf">0.001</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">(</span><span class="bp">True</span><span class="p">):</span>
        <span class="n">attr</span><span class="p">[</span><span class="s1">'x'</span><span class="p">]</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">attr</span><span class="p">[</span><span class="s1">'y'</span><span class="p">]</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">attr</span><span class="p">[</span><span class="s1">'z'</span><span class="p">]</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>

<span class="c1"># ==============================================================================</span>
</code></pre></div>

</div>
</div>
<div class="section">
<h2>The result</h2>
<p>Putting it all together, we get the following script. Simply copy-paste it and run…</p>
<div class="highlight"><pre><code class="language-python border rounded"><span></span><span class="kn">import</span> <span class="nn">ctypes</span>
<span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">compas</span>
<span class="kn">from</span> <span class="nn">compas.datastructures</span> <span class="kn">import</span> <span class="n">Mesh</span>
<span class="kn">from</span> <span class="nn">compas.plotters</span> <span class="kn">import</span> <span class="n">MeshPlotter</span>
<span class="kn">from</span> <span class="nn">compas.interop.core.cpp.xdarray</span> <span class="kn">import</span> <span class="n">Array1D</span>
<span class="kn">from</span> <span class="nn">compas.interop.core.cpp.xdarray</span> <span class="kn">import</span> <span class="n">Array2D</span>


<span class="c1"># get the C++ smoothing library</span>

<span class="n">smoothing</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">cdll</span><span class="o">.</span><span class="n">LoadLibrary</span><span class="p">(</span><span class="s1">'smoothing.so'</span><span class="p">)</span>


<span class="c1"># make a mesh</span>

<span class="n">mesh</span> <span class="o">=</span> <span class="n">Mesh</span><span class="o">.</span><span class="n">from_obj</span><span class="p">(</span><span class="n">compas</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'faces.obj'</span><span class="p">))</span>


<span class="c1"># extract the required data for smoothing</span>

<span class="n">vertices</span>   <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">get_vertices_attributes</span><span class="p">(</span><span class="s1">'xyz'</span><span class="p">)</span>
<span class="n">adjacency</span>  <span class="o">=</span> <span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertex_neighbours</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">()]</span>
<span class="n">fixed</span>      <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertex_degree</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">()]</span>
<span class="n">v</span>          <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
<span class="n">nbrs</span>       <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">adjacency</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span>
<span class="n">neighbours</span> <span class="o">=</span> <span class="p">[</span><span class="n">adjacency</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">10</span> <span class="o">-</span> <span class="n">nbrs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span>
<span class="n">kmax</span>       <span class="o">=</span> <span class="mi">50</span>


<span class="c1"># convert the python data to C-compatible types</span>

<span class="n">c_nbrs</span>       <span class="o">=</span> <span class="n">Array1D</span><span class="p">(</span><span class="n">nbrs</span><span class="p">,</span> <span class="s1">'int'</span><span class="p">)</span>
<span class="n">c_fixed</span>      <span class="o">=</span> <span class="n">Array1D</span><span class="p">(</span><span class="n">fixed</span><span class="p">,</span> <span class="s1">'int'</span><span class="p">)</span>
<span class="n">c_vertices</span>   <span class="o">=</span> <span class="n">Array2D</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="s1">'double'</span><span class="p">)</span>
<span class="n">c_neighbours</span> <span class="o">=</span> <span class="n">Array2D</span><span class="p">(</span><span class="n">neighbours</span><span class="p">,</span> <span class="s1">'int'</span><span class="p">)</span>
<span class="n">c_callback</span>   <span class="o">=</span> <span class="n">CFUNCTYPE</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)</span>


<span class="c1"># make a plotter for visualisation</span>

<span class="n">plotter</span> <span class="o">=</span> <span class="n">MeshPlotter</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>


<span class="c1"># plot the original line geometry as a reference</span>

<span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
        <span class="s1">'start'</span><span class="p">:</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertex_coordinates</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">'xy'</span><span class="p">),</span>
        <span class="s1">'end'</span>  <span class="p">:</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertex_coordinates</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">'xy'</span><span class="p">),</span>
        <span class="s1">'color'</span><span class="p">:</span> <span class="s1">'#cccccc'</span><span class="p">,</span>
        <span class="s1">'width'</span><span class="p">:</span> <span class="mf">0.5</span>
    <span class="p">})</span>

<span class="n">plotter</span><span class="o">.</span><span class="n">draw_lines</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>


<span class="c1"># plot the starting point</span>

<span class="n">plotter</span><span class="o">.</span><span class="n">draw_vertices</span><span class="p">(</span><span class="n">facecolor</span><span class="o">=</span><span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="s1">'#000000'</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span> <span class="k">if</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertex_degree</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">})</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">draw_edges</span><span class="p">()</span>

<span class="n">plotter</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">pause</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>


<span class="c1"># define the callback function</span>

<span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

    <span class="n">xyz</span> <span class="o">=</span> <span class="n">c_vertices</span><span class="o">.</span><span class="n">cdata</span>

    <span class="c1"># change the boundary conditions</span>

    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">kmax</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">xyz</span><span class="p">[</span><span class="mi">18</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># update the plot</span>

    <span class="n">plotter</span><span class="o">.</span><span class="n">update_vertices</span><span class="p">()</span>
    <span class="n">plotter</span><span class="o">.</span><span class="n">update_edges</span><span class="p">()</span>
    <span class="n">plotter</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">pause</span><span class="o">=</span><span class="mf">0.001</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">(</span><span class="bp">True</span><span class="p">):</span>
        <span class="n">attr</span><span class="p">[</span><span class="s1">'x'</span><span class="p">]</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">attr</span><span class="p">[</span><span class="s1">'y'</span><span class="p">]</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">attr</span><span class="p">[</span><span class="s1">'z'</span><span class="p">]</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>


<span class="c1"># set the argument types for the smoothing function</span>
<span class="c1"># and call it with C-compatible data</span>

<span class="n">smoothing</span><span class="o">.</span><span class="n">smooth_centroid</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">c_int</span><span class="p">,</span>
    <span class="n">c_nbrs</span><span class="o">.</span><span class="n">ctype</span><span class="p">,</span>
    <span class="n">c_fixed</span><span class="o">.</span><span class="n">ctype</span><span class="p">,</span>
    <span class="n">c_vertices</span><span class="o">.</span><span class="n">ctype</span><span class="p">,</span>
    <span class="n">c_neighbours</span><span class="o">.</span><span class="n">ctype</span><span class="p">,</span>
    <span class="n">c_int</span><span class="p">,</span>
    <span class="n">c_callback</span>
<span class="p">]</span>

<span class="n">smoothing</span><span class="o">.</span><span class="n">smooth_centroid</span><span class="p">(</span>
    <span class="n">c_int</span><span class="p">(</span><span class="n">v</span><span class="p">),</span>
    <span class="n">c_nbrs</span><span class="o">.</span><span class="n">cdata</span><span class="p">,</span>
    <span class="n">c_fixed</span><span class="o">.</span><span class="n">cdata</span><span class="p">,</span>
    <span class="n">c_vertices</span><span class="o">.</span><span class="n">cdata</span><span class="p">,</span>
    <span class="n">c_neighbours</span><span class="o">.</span><span class="n">cdata</span><span class="p">,</span>
    <span class="n">c_int</span><span class="p">(</span><span class="n">kmax</span><span class="p">),</span>
    <span class="n">c_callback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>
<span class="p">)</span>


<span class="c1"># keep the plotting window alive</span>

<span class="n">plotter</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>

</div>
<div class="section">
<h2>CAD environments</h2>
<p>This setup can also be used in CAD environments.
Assuming that “<em>if it works in RhinoPython, it works everywhere</em>”, here is a script for Rhino
that does the same as the one above,
but uses <code class="xref py py-func docutils literal">compas.geometry.smooth_centroid_cpp()</code> to make things a bit simpler.</p>
<div class="highlight"><pre><code class="language-python border rounded"><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">compas</span>
<span class="kn">import</span> <span class="nn">compas_rhino</span>

<span class="kn">from</span> <span class="nn">compas.datastructures</span> <span class="kn">import</span> <span class="n">Mesh</span>
<span class="kn">from</span> <span class="nn">compas.geometry</span> <span class="kn">import</span> <span class="n">smooth_centroid_cpp</span>

<span class="kn">from</span> <span class="nn">compas_rhino.helpers</span> <span class="kn">import</span> <span class="n">MeshArtist</span>

<span class="n">kmax</span> <span class="o">=</span> <span class="mi">50</span>

<span class="c1"># make a mesh</span>
<span class="c1"># and set the default vertex and edge attributes</span>

<span class="n">mesh</span> <span class="o">=</span> <span class="n">Mesh</span><span class="o">.</span><span class="n">from_obj</span><span class="p">(</span><span class="n">compas</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'faces.obj'</span><span class="p">))</span>

<span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>

<span class="c1"># extract numerical data from the datastructure</span>

<span class="n">vertices</span>  <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">get_vertices_attributes</span><span class="p">((</span><span class="s1">'x'</span><span class="p">,</span> <span class="s1">'y'</span><span class="p">,</span> <span class="s1">'z'</span><span class="p">))</span>
<span class="n">adjacency</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertex_neighbours</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">()]</span>
<span class="n">fixed</span>     <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertex_degree</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">()]</span>

<span class="c1"># make an artist for dynamic visualization</span>
<span class="c1"># and define a callback function</span>
<span class="c1"># for drawing the intermediate configurations</span>
<span class="c1"># and for changing the boundary conditions during the iterations</span>

<span class="n">slider</span> <span class="o">=</span> <span class="mi">30</span>  <span class="c1"># this is the top left corner</span>

<span class="n">artist</span> <span class="o">=</span> <span class="n">MeshArtist</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="s1">'SmoothMesh'</span><span class="p">)</span>

<span class="n">artist</span><span class="o">.</span><span class="n">clear_layer</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">xyz</span><span class="p">):</span>
    <span class="n">compas_rhino</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

    <span class="k">print</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">kmax</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">xyz</span><span class="p">[</span><span class="n">slider</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">artist</span><span class="o">.</span><span class="n">clear_edges</span><span class="p">()</span>
    <span class="n">artist</span><span class="o">.</span><span class="n">draw_edges</span><span class="p">()</span>
    <span class="n">artist</span><span class="o">.</span><span class="n">redraw</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">(</span><span class="bp">True</span><span class="p">):</span>
        <span class="n">attr</span><span class="p">[</span><span class="s1">'x'</span><span class="p">]</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">attr</span><span class="p">[</span><span class="s1">'y'</span><span class="p">]</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">attr</span><span class="p">[</span><span class="s1">'z'</span><span class="p">]</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>


<span class="n">xyz</span> <span class="o">=</span> <span class="n">smooth_centroid_cpp</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">adjacency</span><span class="p">,</span> <span class="n">fixed</span><span class="p">,</span> <span class="n">kmax</span><span class="o">=</span><span class="n">kmax</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">)</span>

<span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">(</span><span class="bp">True</span><span class="p">):</span>
    <span class="n">attr</span><span class="p">[</span><span class="s1">'x'</span><span class="p">]</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">attr</span><span class="p">[</span><span class="s1">'y'</span><span class="p">]</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">attr</span><span class="p">[</span><span class="s1">'z'</span><span class="p">]</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>

<span class="n">artist</span><span class="o">.</span><span class="n">clear_edges</span><span class="p">()</span>
<span class="n">artist</span><span class="o">.</span><span class="n">draw_vertices</span><span class="p">()</span>
<span class="n">artist</span><span class="o">.</span><span class="n">draw_edges</span><span class="p">()</span>
<span class="n">artist</span><span class="o">.</span><span class="n">redraw</span><span class="p">()</span>
</code></pre></div>

</div>
</div>
<!-- <nav class="compas-sideways">
                            
                                <a href="cpython.html" class="btn btn-primary compas-prev" role="button">CPython in Rhino</a>
                            

                            
                                <a href="tools.html" class="btn btn-primary compas-next" role="button">Making tools</a>
                            
                        </nav> -->
</main>
<div class="col-12 col-md-3 col-xl-2 compas-sidebar" role="navigation">
<div class="navbar-light">
<form action="../search.html" class="d-flex compas-searchbox" id="" method="get">
<input class="form-control" name="q" placeholder="Search docs" type="text"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
<button aria-controls="compas-navigation" aria-expanded="false" aria-label="Toggle navigation" class="navbar-toggler d-md-none compas-navigation-toggler" data-target="#compas-navigation" data-toggle="collapse" type="button">
<span class="navbar-toggler-icon"></span>
</button>
</form>
<div class="navbar-expand-md">
<div class="collapse navbar-collapse compas-navigation" id="compas-navigation">
<ul class="nav flex-column active">
<li class="nav-item"><a class="nav-link reference internal" href="../overview.html">Overview</a></li>
<li class="nav-item"><a class="nav-link reference internal" href="../examples.html">Examples</a></li>
<li class="nav-item active"><a class="nav-link reference internal" href="../tutorial.html">Tutorial</a><ul class="nav active">
<li class="nav-item"><a class="nav-link reference internal" href="datastructures.html">Working with datastructures</a></li>
<li class="nav-item"><a class="nav-link reference internal" href="cad.html">CAD integration</a></li>
<li class="nav-item"><a class="nav-link reference internal" href="geomaps.html">Geometric maps</a></li>
<li class="nav-item"><a class="nav-link reference internal" href="callbacks.html">Using callbacks</a></li>
<li class="nav-item"><a class="nav-link reference internal" href="cpython.html">CPython in Rhino</a></li>
<li class="nav-item active"><a class="nav-link active current reference internal" href="#">Using C/C++ code</a></li>
<li class="nav-item"><a class="nav-link reference internal" href="tools.html">Making tools</a></li>
</ul>
</li>
<li class="nav-item"><a class="nav-link reference internal" href="../python.html">Python basics</a></li>
<li class="nav-item"><a class="nav-link reference internal" href="../reference.html">API Reference</a></li>
<li class="nav-item"><a class="nav-link reference internal" href="../citing.html">Citing</a></li>
<li class="nav-item"><a class="nav-link reference internal" href="../releases.html">Versions</a></li>
</ul>
</div>
</div>
</div>
</div>
<div class="d-none d-xl-block col-xl-2 compas-toc" role="toc">
<ul class="nav flex-column" id="compas-localnav">
<li class="nav-item"><a class="nav-link reference internal" href="#">Using C/C++ code</a><ul class="nav">
<li class="nav-item"><a class="nav-link reference internal" href="#summary">Summary</a></li>
<li class="nav-item"><a class="nav-link reference internal" href="#requirements">Requirements</a></li>
<li class="nav-item"><a class="nav-link reference internal" href="#setup">Setup</a></li>
<li class="nav-item"><a class="nav-link reference internal" href="#the-smoothing-function">The smoothing function</a></li>
<li class="nav-item"><a class="nav-link reference internal" href="#the-ctypes-wrapper">The <code class="docutils literal">ctypes</code> wrapper</a><ul class="nav">
<li class="nav-item"><a class="nav-link reference internal" href="#c-compatible-types-and-data">C-compatible types and data</a></li>
</ul>
</li>
<li class="nav-item"><a class="nav-link reference internal" href="#the-result">The result</a></li>
<li class="nav-item"><a class="nav-link reference internal" href="#cad-environments">CAD environments</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<footer class="compas-footer">
            
                
                    © Copyright 2017, Block Research Group - ETH Zurich.
                
            

            
                Last updated on Jan 18, 2018.
            

            
                Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.6.
            
        </footer>
<script type="text/javascript">
var DOCUMENTATION_OPTIONS = {
    URL_ROOT          : '',
    VERSION           : '',
    COLLAPSE_INDEX    : false,
    FILE_SUFFIX       : '.html',
    HAS_SOURCE        : false,
    SOURCELINK_SUFFIX : '.txt'
};
            </script>
<script crossorigin="anonymous" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
<script crossorigin="anonymous" integrity="sha384-b/U6ypiBEHpOf/4+1nzFpr53nxSS+GLCkfwBdFNTxtclqqenISfwAzpKaMNFNmj4" src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.11.0/umd/popper.min.js"></script>
<script crossorigin="anonymous" integrity="sha384-h0AbiXch4ZDo7tp9hKZ4TsHbi047NrKGLO3SEJAg45jXxnGIfYzk4Si90RDIqNm1" src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/js/bootstrap.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.0.0/anchor.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js"></script>
<script src="/_static/underscore.js"></script>
<script src="/_static/doctools.js"></script>
<script src="/_static/js/searchtools_.js"></script>
<script>
hljs.initHighlightingOnLoad();
anchors.add();

var pre = document.getElementsByTagName('pre');

for (var i = 0; i < pre.length; i++) {

    var is_code = pre[i].children[0].className.indexOf('language-python');

    if (is_code === 0) {

        var button = document.createElement('button');

        button.className = 'btn btn-secondary copy-code mt-4';
        button.textContent = 'Copy code';
        button.type = 'button';

        pre[i].appendChild(button);
    }
}

var copy_code = new Clipboard('.copy-code', {
    target: function(trigger) {
        return trigger.previousElementSibling;
    }
});

copy_code.on('success', function(event) {
    event.clearSelection();
    event.trigger.textContent = 'Copied!';
    window.setTimeout(function() {
        event.trigger.textContent = 'Copy code';
    }, 2000);
});

copy_code.on('error', function(event) { 
    event.trigger.textContent = 'Press "Ctrl + C" to copy...';
    window.setTimeout(function() {
        event.trigger.textContent = 'Copy code';
    }, 2000);
});
            </script>
</body>
</html>